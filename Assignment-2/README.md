
# বোনাস সেকশন

Answers to 
- `PostgreSQL কী??` 
- `PostgreSQL-এ ডেটাবেস স্কিমা (database schema)-এর উদ্দেশ্য কী??`



## PostgreSQL কী?

#### PostgreSQL, যা Postgres নামেও পরিচিত, একটি বিনামূল্যে উপলব্ধ (free) এবং উন্মুক্ত-উৎস (open-source) রিলেশনাল ডেটাবেস ম্যানেজমেন্ট সিস্টেম (RDBMS)। এটি এর সম্প্রসারণযোগ্যতা (extensibility) এবং SQL অনুবর্তিতার (SQL compliance) উপর জোর দেয়। PostgreSQL-এর বৈশিষ্ট্যগুলোর মধ্যে রয়েছে ACID (Atomicity, Consistency, Isolation, Durability) বৈশিষ্ট্যসম্পন্ন লেনদেন (transactions), স্বয়ংক্রিয়ভাবে আপডেটযোগ্য ভিউ (automatically updatable views), মেটেরিয়ালাইজড ভিউ (materialized views), ট্রিগার (triggers), ফরেন কি (foreign keys), এবং স্টোরড প্রোসিডিউর (stored procedures)।

#### অন্যান্য RDBMS-এর (রিলেশনাল ডেটাবেস ম্যানেজমেন্ট সিস্টেম) মতো নয়, PostgreSQL নন-রিলেশনাল এবং রিলেশনাল উভয় ডেটা টাইপ সমর্থন করে। এটি এটিকে বর্তমানে উপলব্ধ সবচেয়ে সুসংগত, স্থিতিশীল এবং পরিপক্ক রিলেশনাল ডেটাবেসগুলোর মধ্যে একটি করে তুলেছে।

#### মূলত ১৯৮৬ সালে INGRES (১৯৭০-এর দশকের প্রথম দিকে শুরু হওয়া একটি উন্মুক্ত-উৎস SQL রিলেশনাল ডেটাবেস প্রকল্প)-এর ফলো-আপ হিসেবে তৈরি করা হয়েছিল। POSTGRES, যা এখন PostgreSQL নামে পরিচিত, ছিল বার্কলে-এর কম্পিউটার বিজ্ঞান অধ্যাপক মাইকেল স্টোনব্রেকার (Michael Stonebraker)-এর মস্তিষ্কপ্রসূত। ১৯৯৪ সালে, এই প্রকল্পে SQL-এর জন্য সমর্থন যোগ করা হয় এবং এর অল্প সময়ের মধ্যেই PostgreSQL আত্মপ্রকাশ করে।

### সুবিধা

### - কর্মক্ষমতা এবং মাপযোগ্যতা (Performance and scalability): 

#### বৃহত্তর ডেটাবেস সিস্টেমে যেখানে ডেটা প্রমাণীকরণ (data authentication) এবং পঠন/লেখার গতি (read/write speeds) অত্যাবশ্যক, সেখানে PostgreSQL-কে হারানো কঠিন। PostgreSQL বিভিন্ন পারফরম্যান্স অপটিমাইজেশন সমর্থন করে যা সাধারণত শুধুমাত্র মালিকানাধীন ডেটাবেস প্রযুক্তিতে পাওয়া যায়, যেমন ভূ-স্থানিক সমর্থন (geospatial support) এবং অবাধ সমবর্তন (unrestricted concurrency)। এটি একাধিক ডেটা টাইপের উপর গভীর, ব্যাপক ডেটা বিশ্লেষণ চালানোর সময় PostgreSQL-কে অত্যন্ত কার্যকর করে তোলে।

### - সমবর্তন সমর্থন (Concurrency support):
#### যখন একাধিক ব্যবহারকারী একই সময়ে ডেটা অ্যাক্সেস করে, তখন ঐতিহ্যবাহী ডেটাবেস সিস্টেমগুলো সাধারণত পঠন/লেখার দ্বন্দ্ব এড়াতে রেকর্ডগুলোতে অ্যাক্সেস লক করে দেয়। PostgreSQL MVCC (Multiversion Concurrency Control) ব্যবহারের মাধ্যমে দক্ষতার সাথে সমবর্তন পরিচালনা করে। বাস্তবে, এর অর্থ হলো পঠন লেখা বন্ধ করে না এবং লেখা পঠন বন্ধ করে না।


### -গভীর ভাষা সমর্থন (Deep language support):
#### PostgreSQL ডেভেলপারদের জন্য অন্যতম নমনীয় ডেটাবেস, কারণ এটি একাধিক প্রোগ্রামিং ভাষার সাথে সামঞ্জস্যপূর্ণ এবং তাদের সমর্থন করে। Python, JavaScript, C/C++, Ruby এবং অন্যান্য জনপ্রিয় কোডিং ভাষাগুলো PostgreSQL-এর জন্য পরিপক্ক সমর্থন সরবরাহ করে, যা ডেভেলপারদের সিস্টেমের দ্বন্দ্ব তৈরি না করেই তারা যে ভাষায় পারদর্শী সেই ভাষায় ডেটাবেস কাজগুলো সম্পাদন করতে দেয়।

### - ব্যবসায়িক ধারাবাহিকতা (Business continuity):
#### দুর্যোগের ঘটনায় সংস্থাগুলোকে নিরবচ্ছিন্ন কার্যক্রম বজায় রাখতে হবে। তাদের এমন একটি টেকসই সমাধান প্রয়োজন যা নিশ্চিত করবে যে প্রোডাকশন ডেটাবেসগুলো ক্লায়েন্ট এবং ডেভেলপার উভয়ের কাছেই সর্বদা উপলব্ধ থাকে। PostgreSQL একাধিক সার্ভারে অ্যাসিঙ্ক্রোনাস (Asyncronous) বা সিঙ্ক্রোনাস (Synchronous) রেপ্লিকেশন (replication) পদ্ধতি-এর মাধ্যমে পরিষেবাগুলোর উচ্চ উপলব্ধতা নিশ্চিত করতে কনফিগার করা যেতে পারে।

### - ১০০% উন্মুক্ত উৎস (100% open source):
#### উন্মুক্ত উৎস ডেটাবেস ম্যানেজমেন্ট প্রযুক্তি স্থাপন করা সংস্থাগুলোকে অনন্য সুবিধা প্রদান করে, যার মধ্যে রয়েছে উন্নত খরচ, উচ্চতর নমনীয়তা এবং উদ্ভাবন যা মালিকানাধীন ডেটাবেস সমাধানগুলোতে সবসময় পাওয়া যায় না। বিভিন্ন অবদানকারী দলের দ্বারা তৈরি, PostgreSQL জ্ঞান, দক্ষতা এবং উন্মুক্ত উৎসের মূল্যবোধের একটি শক্তিশালী ভিত্তির উপর নির্মিত, যা এটিকে বিশ্বের সবচেয়ে উন্নত ডেটাবেস করে তুলেছে।

## বৈশিষ্ট্যসমূহ

### - পয়েন্ট-ইন-টাইম রিকভারি (Point-in-time recovery):
#### PostgreSQL ডেভেলপারদের PITR (Point-In-Time Recovery) ব্যবহার করে ডেটা রিকভারি ইনিশিয়েটিভ চালানোর সময় ডেটাবেসগুলোকে একটি নির্দিষ্ট মুহূর্তে পুনরুদ্ধার করতে সক্ষম করে। যেহেতু PostgreSQL সর্বদা একটি রাইট অ্যাহেড লগ (WAL - Write Ahead Log) বজায় রাখে, এটি প্রতিটি ডেটাবেস পরিবর্তন লগ করে। এটি ফাইল সিস্টেমগুলোকে একটি স্থিতিশীল শুরুর অবস্থানে ফিরিয়ে আনা সহজ করে তোলে।

### - স্টোরড প্রোসিডিউর (Stored procedures):
#### PostgreSQL একাধিক প্রসিডিউরাল (procedural) ভাষার জন্য অন্তর্নির্মিত সমর্থন বৈশিষ্ট্যযুক্ত, যা ডেভেলপারদের কাস্টম সাবরুটিন (custom subroutines) তৈরি করার ক্ষমতা দেয় যাকে স্টোরড প্রোসিডিউর বলা হয়। এই প্রোসিডিউরগুলো একটি নির্দিষ্ট ডেটাবেসে তৈরি এবং কল করা যেতে পারে। এক্সটেনশন (extensions) ব্যবহারের মাধ্যমে, প্রসিডিউরাল ভাষাগুলো Perl, Python, JavaScript এবং Ruby সহ অন্যান্য অনেক প্রোগ্রামিং ভাষাতেও ডেভেলপমেন্টের জন্য ব্যবহার করা যেতে পারে।


##  PostgreSQL-এ স্কিমার উদ্দেশ্য কী?

#### PostgreSQL-এ, স্কিমা হল ডেটাবেইজ অবজেক্টগুলোর (যেমন টেবিল, ভিউ, ইনডেক্স, ডেটা টাইপ, ফাংশন, স্টোরড প্রোসিজার, অপারেটর) একটি নামযুক্ত সংগ্রহ।

#### স্কিমা ব্যবহার করে আপনি ডেটাবেইজ অবজেক্টগুলোকে গুছিয়ে রাখতে পারেন এবং তাদের জন্য আলাদা namespace তৈরি করতে পারেন।

#### স্কিমার ভেতরের কোনো অবজেক্ট অ্যাক্সেস করতে চাইলে নিচের মতো করে কোয়ালিফাই করে নাম ব্যবহার করতে হয়:

```SQL
schema_name.object_name
```

#### একটি ডেটাবেইজে একাধিক স্কিমা থাকতে পারে, তবে প্রতিটি স্কিমা শুধু একটি ডেটাবেইজের অংশ হয়। একই ডেটাবেইজে দুইটি স্কিমায় এক নামের আলাদা অবজেক্ট থাকতে পারে।

#### উদাহরণস্বরূপ, ধরুন `sales` স্কিমায় একটি `staff` টেবিল আছে এবং `public` স্কিমাতেও একই নামে আরেকটি টেবিল আছে। তখন যদি `staff` টেবিল রেফার করতে হয়, তাহলে নিচের মতো করে করতে হবে:

```SQL
public.staff
```
#### অথবা

```SQL
sales.staff
```

#### স্কিমা উপকারী হয় নিচের পরিস্থিতিতে:

- স্কিমা ডেটাবেইজ অবজেক্টগুলোকে যেমন টেবিল—লজিক্যাল গ্রুপে সাজাতে সাহায্য করে, যাতে ম্যানেজ করা সহজ হয়।
- একই ডেটাবেইজে একাধিক ব্যবহারকারীকে একসাথে কাজ করার সুযোগ দেয়, একে অপরের ডেটায় হস্তক্ষেপ না করেই।

###  Public স্কিমা

#### PostgreSQL প্রতিটি নতুন ডেটাবেইজের জন্য স্বয়ংক্রিয়ভাবে একটি `public` স্কিমা তৈরি করে। আপনি যদি কোনো স্কিমার নাম না দিয়ে অবজেক্ট তৈরি করেন, PostgreSQL সেটিকে `public` স্কিমায় রেখে দেয়। তাই নিচের দুটি স্টেটমেন্ট একই রকম:

```sql
CREATE TABLE table_name(
  ...
);
```
### এবং
```sql
CREATE TABLE public.table_name(
   ...
);
```

###  স্কিমা সার্চ পাথ

#### বাস্তবে আপনি টেবিলের নাম সরাসরি ব্যবহার করেন, যেমন `staff` — পুরো `sales.staff` লেখার বদলে।

#### PostgreSQL টেবিল খুঁজে পেতে স্কিমা সার্চ পাথ ব্যবহার করে, যেখানে কোন কোন স্কিমায় খুঁজবে সেটির তালিকা থাকে।

#### PostgreSQL প্রথম যেই স্কিমায় ম্যাচিং অবজেক্ট পাবে সেটিই ব্যবহার করবে। না পেলে ভুল দেখাবে, যদিও অন্য স্কিমায় ওই নামের অবজেক্ট থাকলেও।

#### এই তালিকার প্রথম স্কিমাকে বলা হয় "current schema"। আপনি যদি কোনো অবজেক্ট তৈরি করেন এবং স্কিমার নাম না দেন, তাহলে PostgreSQL current schema-তেই রাখবে।

বর্তমান স্কিমা জানতে নিচের ফাংশন ব্যবহার করুন:

```sql
SELECT current_schema();
```

#### আউটপুট হবে:

```sql
current_schema
----------------
public
(1 row)
```

#### তাই PostgreSQL নতুন অবজেক্ট তৈরি করলে `public` স্কিমা ব্যবহার করে।

বর্তমান সার্চ পাথ দেখতে `SHOW` কমান্ড ব্যবহার করতে পারেন:

```sql
SHOW search_path;
```

#### আউটপুট:

```sql
search_path
-----------------
"$user", public
(1 row)
```

#### এখানে:

- `"$user"` মানে প্রথমে PostgreSQL সেই স্কিমায় খুঁজবে যার নাম ইউজারের নামের সঙ্গে মেলে। যেমন, `postgres` ইউজার দিয়ে লগইন করলে PostgreSQL `postgres` স্কিমায় খুঁজবে। না পেলে `public` স্কিমায় যাবে।
- দ্বিতীয় আইটেম `public`, যা ডিফল্ট স্কিমা।

নতুন স্কিমা তৈরি করতে:

```sql
CREATE SCHEMA sales;
```

#### এই স্কিমাকে সার্চ পাথে আনতে:

```sql
SET search_path TO sales, public;
```

#### এখন আপনি `staff` টেবিল তৈরি করলে, সেটা `sales` স্কিমায় যাবে:

```sql
CREATE TABLE staff(
    staff_id SERIAL PRIMARY KEY,
    first_name VARCHAR(45) NOT NULL,
    last_name VARCHAR(45) NOT NULL,
    email VARCHAR(100) NOT NULL UNIQUE
);
```

#### `sales` স্কিমার `staff` টেবিল অ্যাক্সেস করতে নিচের যে কোনোটি ব্যবহার করতে পারেন:

```sql
SELECT * FROM staff;
```
#### অথবা

```sql
SELECT * FROM sales.staff;
```

#### `public` স্কিমা যদি দ্বিতীয় হয় সার্চ পাথে, তাহলে তার টেবিল অ্যাক্সেস করতে স্কিমা কোয়ালিফাই করে লিখতে হবে:

```sql
SELECT * FROM public.staff;
```

#### নিচের কমান্ড দিলে আপনাকে `public` স্কিমার অবজেক্টগুলো রেফার করার সময় পুরো নাম লিখতে হবে:

```sql
SET search_path TO public;
```

#### `public` স্কিমা বিশেষ কিছু নয়, চাইলে এটিকে ডিলিটও করা যায়।

###  PostgreSQL স্কিমা ও প্রিভিলেজ

#### ব্যবহারকারীরা কেবল সেই স্কিমার অবজেক্ট অ্যাক্সেস করতে পারে যেগুলোর মালিক তারা।

#### অন্য স্কিমার অবজেক্ট অ্যাক্সেস করতে দিতে চাইলে, ওই স্কিমায় `USAGE` প্রিভিলেজ দিতে হবে:

```sql
GRANT USAGE ON SCHEMA schema_name
TO role_name;
```

#### অবজেক্ট তৈরি করতে দিতে চাইলে `CREATE` প্রিভিলেজ দিতে হবে:

```sql
GRANT CREATE ON SCHEMA schema_name
TO user_name;
```

#### ডিফল্টভাবে, প্রতিটি ইউজার `public` স্কিমায় `CREATE` ও `USAGE` প্রিভিলেজ পায়।

###  PostgreSQL স্কিমা অপারেশন

- নতুন স্কিমা তৈরি করতে: `CREATE SCHEMA`
- স্কিমার নাম বা মালিক পরিবর্তন করতে: `ALTER SCHEMA`
- স্কিমা ডিলিট করতে: `DROP SCHEMA`
